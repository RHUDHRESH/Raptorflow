import {
  CouncilRequest,
  CouncilResponse,
  CouncilMoveSuggestion,
  CouncilCampaignArc,
  ChecklistItem,
  Campaign,
  Move,
} from './campaigns-types';
import { apiFetch, getAuthHeaders } from './backend';
import foundationMetadata from './foundation_test.json';

const COUNCIL_MOVE_ENDPOINT = '/council/generate_move_plan';
const COUNCIL_CAMPAIGN_ENDPOINT = '/council/generate_campaign_plan';
const COUNCIL_SAVE_MOVES_ENDPOINT = '/council/moves/create';
const COUNCIL_SAVE_CAMPAIGN_ENDPOINT = '/council/campaigns/create';

const DEFAULT_CONFIDENCE = 0.78;

function pickCouncilMoves(payload: any): any[] {
  return (
    payload.approved_moves ||
    payload.refined_moves ||
    payload.proposed_moves ||
    payload.suggested_moves ||
    []
  );
}

function toCouncilResponse(payload: any, type: 'move' | 'campaign'): CouncilResponse {
  const consensus = payload.consensus_metrics || {};
  const confidenceRaw =
    typeof consensus.confidence === 'number'
      ? consensus.confidence
      : DEFAULT_CONFIDENCE;
  const confidence = Math.round(confidenceRaw * 100);
  const moves = pickCouncilMoves(payload).map((move: any, index: number) => ({
    id: move.id || `move-${index}-${Date.now()}`,
    title: move.title || 'Untitled Move',
    description: move.description || 'No description provided.',
    type: move.move_type || 'other',
    toolRequirements: move.tool_requirements || [],
    confidenceScore: move.confidence_score || confidence,
    rationale: move.rationale || 'Generated by the Council.',
  }));

  const campaignArc: CouncilCampaignArc | undefined = payload.campaign_data
    ? {
        title: payload.campaign_data.title || 'Campaign',
        objective: payload.campaign_data.objective || 'launch',
        phases: (payload.campaign_data.arc_data?.phases || []).map(
          (phase: any, idx: number) => ({
            name: phase.name || `Phase ${idx + 1}`,
            weeks: phase.weeks || [],
            focus: phase.focus || phase.summary || 'Focus pending',
          })
        ),
        milestones: payload.campaign_data.arc_data?.milestones || [],
      }
    : undefined;

  return {
    type,
    strategicDecree: payload.decree || 'Awaiting Council decree.',
    confidence,
    risks: (payload.rejected_paths || []).map((path: any) => path.reason || ''),
    debateTranscript: (payload.debate_history || []).map((entry: any) => ({
      role: entry.agent_name || entry.role || 'Council',
      argument: entry.content || entry.argument || '',
    })),
    rejectedPaths: (payload.rejected_paths || []).map((path: any) => ({
      path: path.path || path.title || 'Rejected path',
      reason: path.reason || 'Not selected',
    })),
    moves: type === 'move' ? moves : undefined,
    campaignArc: type === 'campaign' ? campaignArc : undefined,
    campaignMoves: type === 'campaign' ? moves : undefined,
  };
}

export const generateCouncilProposal = async (
  request: CouncilRequest
): Promise<CouncilResponse> => {
  const plan = await generateCouncilPlan(request);
  return plan.view;
};

export const generateCouncilPlan = async (
  request: CouncilRequest
): Promise<{ view: CouncilResponse; raw: any }> => {
  const headers = await getAuthHeaders();
  const workspaceId = headers['X-Tenant-ID'];
  const payload = {
    workspace_id: workspaceId,
    objective: request.objective,
    details: request.context,
  };

  if (request.type === 'move') {
    const response = await apiFetch<any>(COUNCIL_MOVE_ENDPOINT, {
      method: 'POST',
      headers,
      body: JSON.stringify(payload),
    });
    return { view: toCouncilResponse(response, 'move'), raw: response };
  }

  const campaignPayload = {
    ...payload,
    target_icp: request.context.slice(0, 120),
  };
  const response = await apiFetch<any>(COUNCIL_CAMPAIGN_ENDPOINT, {
    method: 'POST',
    headers,
    body: JSON.stringify(campaignPayload),
  });
  return { view: toCouncilResponse(response, 'campaign'), raw: response };
};

export const persistCouncilMoves = async (
  rawPlan: any,
  moves: CouncilMoveSuggestion[]
): Promise<void> => {
  const headers = await getAuthHeaders();
  const workspaceId = headers['X-Tenant-ID'];
  const refinementDataBase = {
    foundation_metadata: foundationMetadata,
  };

  const payload = {
    workspace_id: workspaceId,
    campaign_id: rawPlan.campaign_id || null,
    rationale: {
      final_decree: rawPlan.decree || 'Council decree',
      consensus_metrics: rawPlan.consensus_metrics || { confidence: DEFAULT_CONFIDENCE },
      reasoning_chain_id: rawPlan.reasoning_chain_id || null,
    },
    moves: moves.map((move) => ({
      title: move.title,
      description: move.description,
      move_type: move.type || 'other',
      priority: 3,
      tool_requirements: move.toolRequirements || [],
      muse_prompt: move.rationale || null,
      refinement_data: refinementDataBase,
    })),
  };

  await apiFetch(COUNCIL_SAVE_MOVES_ENDPOINT, {
    method: 'POST',
    headers,
    body: JSON.stringify(payload),
  });
};

export const persistCouncilCampaign = async (
  rawPlan: any,
  moves: CouncilMoveSuggestion[]
): Promise<void> => {
  const headers = await getAuthHeaders();
  const workspaceId = headers['X-Tenant-ID'];
  const refinementDataBase = {
    foundation_metadata: foundationMetadata,
  };

  const payload = {
    workspace_id: workspaceId,
    campaign_data: {
      title: rawPlan.campaign_data?.title || 'Campaign',
      objective: rawPlan.campaign_data?.objective || 'launch',
      arc_data: rawPlan.campaign_data?.arc_data || {},
      status: 'draft',
    },
    moves: moves.map((move) => ({
      title: move.title,
      description: move.description,
      move_type: move.type || 'other',
      priority: 3,
      tool_requirements: move.toolRequirements || [],
      muse_prompt: move.rationale || null,
      refinement_data: refinementDataBase,
    })),
  };

  await apiFetch(COUNCIL_SAVE_CAMPAIGN_ENDPOINT, {
    method: 'POST',
    headers,
    body: JSON.stringify(payload),
  });
};

export const createMoveFromProposal = async (
  move: Partial<Move>
): Promise<void> => {
  const headers = await getAuthHeaders();
  const workspaceId = headers['X-Tenant-ID'];

  const refinementData = {
    ...(move.refinementData || {}),
    foundation_metadata: foundationMetadata,
  };

  const payload = {
    workspace_id: workspaceId,
    campaign_id: move.campaignId || null,
    rationale: {
      final_decree: move.description || 'Council generated move.',
      consensus_metrics: { confidence: DEFAULT_CONFIDENCE },
      reasoning_chain_id: move.id || null,
    },
    moves: [
      {
        title: move.name || 'New Move',
        description: move.description || '',
        move_type: move.channel || 'other',
        priority: 3,
        tool_requirements: move.toolRequirements || [],
        muse_prompt: move.refinementData?.muse_prompt || null,
        refinement_data: refinementData,
      },
    ],
  };

  await apiFetch(COUNCIL_SAVE_MOVES_ENDPOINT, {
    method: 'POST',
    headers,
    body: JSON.stringify(payload),
  });
};

export const createCampaignFromProposal = async (
  campaign: any
): Promise<void> => {
  const headers = await getAuthHeaders();
  const workspaceId = headers['X-Tenant-ID'];
  const payload = {
    workspace_id: workspaceId,
    campaign_data: {
      title: campaign.name || 'New Campaign',
      objective: campaign.objective || 'launch',
      arc_data: campaign.strategyArc || {},
      status: 'draft',
    },
    moves: [],
  };

  await apiFetch(COUNCIL_SAVE_CAMPAIGN_ENDPOINT, {
    method: 'POST',
    headers,
    body: JSON.stringify(payload),
  });
};

export async function updateCampaign(
  id: string,
  updates: Partial<Campaign>
): Promise<void> {
  const headers = await getAuthHeaders();
  const payload = {
    title: updates.name,
    objective: updates.objective,
    status: updates.status,
    arc_data: updates.strategyArc,
  };

  await apiFetch(`/v1/campaigns/${id}`, {
    method: 'PUT',
    headers,
    body: JSON.stringify(payload),
  });
}

export async function getMoveRationale(moveId: string): Promise<CouncilResponse> {
  const headers = await getAuthHeaders();
  const response = await apiFetch<any>(`/v1/moves/${moveId}/rationale`, {
    headers,
  });

  return {
    type: 'move',
    strategicDecree: response.decree || 'Rationale pending.',
    confidence: Math.round((response.confidence || DEFAULT_CONFIDENCE) * 100),
    risks: response.rejected_paths?.map((path: any) => path.reason || '') || [],
    debateTranscript:
      response.debate_rounds?.flatMap((round: any) =>
        (round.proposals || []).map((proposal: any) => ({
          role: proposal.agent_id || 'Council',
          argument: proposal.content || '',
        }))
      ) || [],
    rejectedPaths:
      response.rejected_paths?.map((path: any) => ({
        path: path.path || 'Rejected path',
        reason: path.reason || 'Not selected',
      })) || [],
  };
}

export async function updateMove(
  id: string,
  updates: Partial<Move>
): Promise<void> {
  const headers = await getAuthHeaders();
  const payload = {
    title: updates.name,
    description: updates.description,
    status: updates.status,
    confidence: updates.confidence,
    started_at: updates.startedAt,
    completed_at: updates.completedAt,
    paused_at: updates.pausedAt,
  };

  await apiFetch(`/v1/moves/${id}`, {
    method: 'PUT',
    headers,
    body: JSON.stringify(payload),
  });
}

export async function updateMoveTasks(
  moveId: string,
  tasks: ChecklistItem[]
): Promise<void> {
  const headers = await getAuthHeaders();
  await Promise.all(
    tasks.map((task) =>
      apiFetch(`/v1/moves/${moveId}/tasks/${task.id}`, {
        method: 'PUT',
        headers,
        body: JSON.stringify({ completed: task.completed }),
      })
    )
  );
}
