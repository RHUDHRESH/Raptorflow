# RaptorFlow Onboarding Backend — Complete Industrial Specification
## Python/FastAPI Backend for Foundation, ICP Generation, Competitive Intelligence & Positioning

---

# 1. SCOPE

This specification covers the complete onboarding intelligence pipeline:
1. **Foundation Collection** — Storing user-submitted business data
2. **ICP Generation** — AI-driven Ideal Customer Profile synthesis
3. **Competitive Derivation** — The UCDA Algorithm (Status Quo → Indirect → Direct)
4. **Positioning Derivation** — The 5-Stage Algorithm (Gap → Attribute → Ladder → Fit → Proof)
5. **Three Representations** — Statement, Ladder, Perceptual Map
6. **Soundbite Generation** — Tactical messaging for all awareness levels

---

# 2. THE UNIVERSAL COMPETITIVE DERIVATION ALGORITHM (UCDA)

## 2.1 Core Philosophy
**Competition is defined by DISPLACEMENT.** To find a competitor, find what you are **deleting** from the customer's life.

## 2.2 The Three Vectors

### Vector 1: Status Quo (The "Inertia Crawler")
```python
def derive_status_quo(foundation: dict) -> dict:
    """
    Set [Purchase_Intent] to FALSE.
    Ask: "How does the customer achieve [JOB] right now using only internal resources?"
    """
    alternatives = foundation.get("alternatives", [])

    internal_alternatives = [a for a in alternatives if a in [
        "spreadsheets", "notion", "zapier-glue", "internal-team", "nothing"
    ]]

    if "spreadsheets" in internal_alternatives or "notion" in internal_alternatives:
        mechanism = "The DIY Stack"
        description = "Google Sheets + Notion docs + Founders working until 2 AM"
    elif "zapier-glue" in internal_alternatives:
        mechanism = "The Frankenstein System"
        description = "Zapier automations + disconnected tools duct-taped together"
    elif "internal-team" in internal_alternatives:
        mechanism = "The Human Workaround"
        description = "Hiring junior staff to manually execute what should be automated"
    elif "nothing" in internal_alternatives:
        mechanism = "Non-Consumption"
        description = "The problem is currently ignored"
    else:
        mechanism = "The Status Quo"
        description = "Manual labor + brute-force effort"

    pains = foundation.get("pain_ranking", [])
    tolerated_pain = pains[0] if pains else foundation.get("confession_friction", "Unknown pain")

    return {
        "type": "status_quo",
        "name": mechanism,
        "description": description,
        "manual_patches": internal_alternatives,
        "tolerated_pain": tolerated_pain,
        "your_wedge": "Automation + Intelligence replaces manual chaos"
    }
```

### Vector 2: Indirect Competitors (The "Budget Reallocation" Algorithm)
```python
def derive_indirect_competitors(foundation: dict) -> list:
    """
    The "CFO Veto" Test:
    If you have budget but cannot buy a tool, who do you write the check to?
    """
    alternatives = foundation.get("alternatives", [])
    service_alternatives = [a for a in alternatives if a in ["agencies", "freelancers"]]

    indirect = []

    if "agencies" in service_alternatives:
        indirect.append({
            "name": "Marketing Agencies",
            "mechanism": "Outsourced execution via humans",
            "price_range": "$2,000 - $10,000/month",
            "weakness": "Slow, expensive, no founder voice",
            "your_edge": "Speed + Authenticity + 10x cheaper"
        })

    if "freelancers" in service_alternatives:
        indirect.append({
            "name": "Freelancers / VAs",
            "mechanism": "Cheap human labor for individual tasks",
            "price_range": "$500 - $2,000/month",
            "weakness": "No strategy, needs constant management",
            "your_edge": "Strategic brain + consistent execution"
        })

    return indirect
```

### Vector 3: Direct Competitors (The "Feature Collision" Algorithm)
```python
def derive_direct_competitors(foundation: dict) -> list:
    """
    The "Review Scraping" Protocol:
    - Go to G2/Capterra, look at category leader
    - Filter reviews by 1-Star and 2-Star
    - Read the complaints
    """
    business_type = foundation.get("business_type", "saas")

    direct_map = {
        "saas": [
            {"name": "HubSpot", "positioning": "All-In-One Marketing Cloud",
             "weakness": "Complex, expensive, siloed", "your_edge": "Unified simplicity", "feature_overlap": "high"},
            {"name": "ActiveCampaign", "positioning": "Email + Automation for SMBs",
             "weakness": "No strategic layer", "your_edge": "Strategy + Execution", "feature_overlap": "medium"}
        ]
    }

    return direct_map.get(business_type, direct_map["saas"])
```

---

# 3. THE POSITIONING DERIVATION ALGORITHM™

## 3.1 Overview
This algorithm takes the 6 data objects and systematically derives positioning—no guessing, no vibes, pure data logic.

**Input:** 6 Data Objects
1. `BusinessSnapshot` (from Foundation)
2. `BestCustomerSeeds` (from Foundation.best_customers)
3. `BuyingSystem` (from Foundation cohort data)
4. `Alternatives` (from Foundation.alternatives)
5. `PainMap` (from Foundation.pain_ranking + confessions)
6. `Proof` (from Foundation.proof_types)

**Output:** 3 Representations
1. Positioning Statement
2. Attribute Ladder
3. Perceptual Map (2x2 Grid)

---

## 3.2 Stage 1: Market Gap Analysis

**Input:** `Alternatives` + `PainMap` + `BestCustomerSeeds`
**Output:** Uncrowded position thesis

**The Algorithm:**
```python
def stage1_market_gap_analysis(foundation: dict, competitive: dict) -> dict:
    """
    Identify what pain ZERO competitors solve well.
    This becomes your positioning wedge.
    """

    # Get all pains
    pains = foundation.get("pain_ranking", [])
    confession_pains = [
        foundation.get("confession_expensive_problem", ""),
        foundation.get("confession_friction", "")
    ]
    all_pains = pains + [p for p in confession_pains if p]

    # Get competitor weaknesses
    direct = competitive.get("direct_competitors", [])
    indirect = competitive.get("indirect_competitors", [])
    status_quo = competitive.get("status_quo", {})

    competitor_weaknesses = []
    for c in direct:
        competitor_weaknesses.append(c.get("weakness", ""))
    for c in indirect:
        competitor_weaknesses.append(c.get("weakness", ""))
    competitor_weaknesses.append(status_quo.get("tolerated_pain", ""))

    # Find the GAP: pains that map to competitor weaknesses
    gap_candidates = []
    for pain in all_pains:
        pain_lower = pain.lower()
        for weakness in competitor_weaknesses:
            weakness_lower = weakness.lower()
            # Check if pain relates to a competitor weakness
            if any(keyword in weakness_lower for keyword in pain_lower.split()):
                gap_candidates.append({
                    "pain": pain,
                    "competitor_weakness": weakness,
                    "gap_strength": "high"
                })

    # Select the strongest gap
    primary_gap = gap_candidates[0] if gap_candidates else {
        "pain": all_pains[0] if all_pains else "Unknown gap",
        "competitor_weakness": "None identified",
        "gap_strength": "low"
    }

    return {
        "gap_thesis": f"Nobody solves '{primary_gap['pain']}' well",
        "gap_pain": primary_gap["pain"],
        "competitor_failure": primary_gap["competitor_weakness"],
        "gap_strength": primary_gap["gap_strength"],
        "your_wedge": f"We solve {primary_gap['pain']} where competitors fail"
    }
```

---

## 3.3 Stage 2: Attribute Prioritization

**Input:** `PainMap` (ranked pains) + `BestCustomerSeeds` (why they chose you)
**Output:** Your One Thing (single ownable concept)

**The Algorithm:**
```python
def stage2_attribute_prioritization(foundation: dict, gap_analysis: dict) -> dict:
    """
    Extract the primary pain. Verify it's:
    1. Specific (not vague)
    2. Urgent (triggers buying)
    3. Owned by zero competitors (defensible)

    Score it. If ≥4/5, that pain becomes your One Thing.
    """

    primary_pain = gap_analysis.get("gap_pain", "")
    trigger_events = foundation.get("trigger_events", [])

    # SPECIFICITY TEST (1/5)
    specificity_score = 0
    vague_words = ["better", "more", "good", "improve", "help"]
    if not any(v in primary_pain.lower() for v in vague_words):
        specificity_score = 1

    # URGENCY TEST (1/5) - Check if related to trigger events
    urgency_score = 0
    urgent_triggers = ["missed-target", "funding-round", "churn-spike", "compliance-change"]
    if any(t in trigger_events for t in urgent_triggers):
        urgency_score = 1

    # OWNERSHIP TEST (1/5) - No competitor owns this
    ownership_score = 0
    if gap_analysis.get("gap_strength") == "high":
        ownership_score = 1

    # EMOTIONAL RESONANCE TEST (1/5)
    emotional_score = 0
    scarf_drivers = foundation.get("scarf_drivers", [])
    if len(scarf_drivers) > 0:
        emotional_score = 1

    # PROOF AVAILABLE TEST (1/5)
    proof_score = 0
    proof_types = foundation.get("proof_types", [])
    if "case-study" in proof_types or "metrics" in proof_types:
        proof_score = 1

    total_score = specificity_score + urgency_score + ownership_score + emotional_score + proof_score

    # Derive the ONE THING
    one_thing_candidates = {
        "Strategic Clarity": ["strategy", "direction", "plan", "clarity"],
        "Execution Speed": ["fast", "speed", "quick", "time"],
        "Unified Control": ["control", "unified", "one place", "system"],
        "Founder-Friendly": ["simple", "easy", "founder", "lean"]
    }

    one_thing = "Strategic Control"  # Default
    for candidate, keywords in one_thing_candidates.items():
        if any(k in primary_pain.lower() for k in keywords):
            one_thing = candidate
            break

    return {
        "one_thing": one_thing,
        "primary_pain": primary_pain,
        "score": total_score,
        "score_breakdown": {
            "specificity": specificity_score,
            "urgency": urgency_score,
            "ownership": ownership_score,
            "emotional": emotional_score,
            "proof": proof_score
        },
        "is_valid": total_score >= 4,
        "validation_message": "Strong One Thing" if total_score >= 4 else "Consider refining positioning"
    }
```

---

## 3.4 Stage 3: Competitive Mapping (The Attribute Ladder)

**Input:** `Your One Thing` + `All Competitors`
**Output:** Attribute ladder showing where you rank

**The Algorithm:**
```python
def stage3_competitive_mapping(
    one_thing: str,
    status_quo: dict,
    indirect: list,
    direct: list
) -> dict:
    """
    Build a visual ladder ranking all solutions on your ownable attribute.
    You MUST own the top position.
    """

    ladder = [
        {
            "position": 5,
            "name": "RaptorFlow",
            "description": f"Complete {one_thing} system",
            "is_you": True,
            "score": 10
        }
    ]

    # Add direct competitors
    for i, comp in enumerate(direct[:2]):
        ladder.append({
            "position": 4 - i,
            "name": comp["name"],
            "description": comp["positioning"],
            "is_you": False,
            "score": 7 - i
        })

    # Add indirect competitors
    for i, comp in enumerate(indirect[:1]):
        ladder.append({
            "position": 2,
            "name": comp["name"],
            "description": comp["mechanism"],
            "is_you": False,
            "score": 4
        })

    # Add status quo at bottom
    ladder.append({
        "position": 1,
        "name": status_quo["name"],
        "description": status_quo["description"],
        "is_you": False,
        "score": 1
    })

    # Sort by position descending
    ladder.sort(key=lambda x: x["position"], reverse=True)

    # Calculate defensibility gap
    your_score = 10
    next_best = max([l["score"] for l in ladder if not l["is_you"]], default=0)
    gap = your_score - next_best

    defensibility = "low"
    if gap >= 3:
        defensibility = "high"
    elif gap >= 2:
        defensibility = "medium"

    return {
        "ladder": ladder,
        "attribute": one_thing,
        "defensibility": defensibility,
        "gap_to_next": gap,
        "message": f"You own the top of the '{one_thing}' ladder with a {gap}-point gap"
    }
```

---

## 3.5 Stage 4: Audience-Attribute Fit

**Input:** `BestCustomerSeeds` + `BuyingSystem` + `PainMap`
**Output:** Primary ICP (highest-fit customer segment)

**The Algorithm:**
```python
def stage4_audience_attribute_fit(foundation: dict, icps: list, one_thing: str) -> dict:
    """
    Score each ICP archetype:
    +1: Feels primary pain?
    +1: In trigger event?
    +1: Using failed competitor?
    +1: Can afford your price?

    Highest score = Primary ICP.
    """

    scored_icps = []

    for icp in icps:
        score = 0

        # +1: Feels primary pain?
        primary_pains = icp.get("pain_map", {}).get("primaryPains", [])
        if any(one_thing.lower() in pain.lower() for pain in primary_pains):
            score += 1
        else:
            score += 0.5  # Partial credit if they have ANY pain

        # +1: In trigger event?
        triggers = icp.get("pain_map", {}).get("triggerEvents", [])
        urgent_triggers = ["funding-round", "missed-target", "churn-spike"]
        if any(t in triggers for t in urgent_triggers):
            score += 1

        # +1: Using failed competitor?
        # (If their current solution is the status quo, they're ripe)
        firmographics = icp.get("firmographics", {})
        if "spreadsheets" in str(firmographics) or "nothing" in str(firmographics):
            score += 1

        # +1: Can afford your price?
        budget = firmographics.get("budgetComfort", [])
        if any(b in ["medium", "high", "5k-25k", "25k-1l"] for b in budget):
            score += 1

        scored_icps.append({
            "icp": icp,
            "fit_score": score,
            "max_score": 4
        })

    # Sort by score
    scored_icps.sort(key=lambda x: x["fit_score"], reverse=True)

    primary_icp = scored_icps[0] if scored_icps else None

    return {
        "primary_icp": primary_icp["icp"]["name"] if primary_icp else "Unknown",
        "primary_icp_id": primary_icp["icp"]["id"] if primary_icp else None,
        "fit_score": primary_icp["fit_score"] if primary_icp else 0,
        "all_scored": [
            {"name": s["icp"]["name"], "score": s["fit_score"]}
            for s in scored_icps
        ],
        "is_perfect_fit": primary_icp["fit_score"] >= 4 if primary_icp else False
    }
```

---

## 3.6 Stage 5: Proof Stack Validation

**Input:** `ProofAndConstraints`
**Output:** Proof hierarchy + gap analysis

**The Algorithm:**
```python
def stage5_proof_stack_validation(foundation: dict) -> dict:
    """
    Organize proof by strength:
    - Tier 1 (Strongest): Quantified case studies
    - Tier 2 (Strong): Analyst positioning
    - Tier 3 (Medium): Customer testimonials
    - Tier 4 (Weak): Brand claims only

    Identify gaps.
    """

    proof_types = foundation.get("proof_types", [])

    proof_stack = {
        "tier_1": {
            "name": "Quantified Case Studies",
            "strength": "strongest",
            "available": "case-study" in proof_types or "metrics" in proof_types,
            "recommendation": "Create 3 case studies with specific ROI numbers" if "case-study" not in proof_types else None
        },
        "tier_2": {
            "name": "Analyst/Expert Positioning",
            "strength": "strong",
            "available": False,  # Rarely available for early-stage
            "recommendation": "Get featured in industry reports or analyst coverage"
        },
        "tier_3": {
            "name": "Customer Testimonials",
            "strength": "medium",
            "available": "testimonials" in proof_types,
            "recommendation": "Collect 5+ video testimonials" if "testimonials" not in proof_types else None
        },
        "tier_4": {
            "name": "Brand Claims",
            "strength": "weak",
            "available": True,  # Always available
            "recommendation": "Avoid relying on claims alone"
        },
        "tier_5": {
            "name": "Logos / Social Proof",
            "strength": "supporting",
            "available": "logos" in proof_types,
            "recommendation": "Display customer logos prominently" if "logos" not in proof_types else None
        }
    }

    # Calculate overall proof strength
    available_count = sum(1 for t in proof_stack.values() if t["available"])

    if available_count >= 4:
        overall_strength = "strong"
    elif available_count >= 2:
        overall_strength = "medium"
    else:
        overall_strength = "weak"

    # Identify gaps
    gaps = [tier["recommendation"] for tier in proof_stack.values() if tier["recommendation"]]

    return {
        "proof_stack": proof_stack,
        "overall_strength": overall_strength,
        "available_tiers": available_count,
        "gaps": gaps,
        "priority_action": gaps[0] if gaps else "Proof stack is strong"
    }
```

---

# 4. THE THREE POSITIONING REPRESENTATIONS

## 4.1 Representation 1: The Positioning Statement

**Structure:**
```
For [Primary ICP],
[Company] is the [Category]
that [One Thing]
unlike [Competitor],
because [Proof/Mechanism].
```

**The Algorithm:**
```python
def generate_positioning_statement(
    foundation: dict,
    primary_icp: str,
    one_thing: str,
    direct_competitor: dict,
    proof_stack: dict
) -> dict:
    """
    Every element is data-backed:
    - ICP from Stage 4
    - One Thing from Stage 2
    - Competitor from Stage 3
    - Proof from Stage 5
    """

    company = foundation.get("business_name", "RaptorFlow")
    category = foundation.get("category", "Marketing Operating System")

    # Build the statement
    statement = {
        "for_whom": primary_icp,
        "company": company,
        "category": category,
        "one_thing": one_thing,
        "competitor": direct_competitor.get("name", "Legacy tools"),
        "competitor_weakness": direct_competitor.get("weakness", "complex and fragmented"),
        "proof": "case studies with measurable ROI" if proof_stack.get("overall_strength") == "strong" else "proven founder methodology"
    }

    # Generate the full statement
    full_text = f"For {statement['for_whom']}, {statement['company']} is the {statement['category']} that provides {statement['one_thing']}, unlike {statement['competitor']} which is {statement['competitor_weakness']}, because we deliver {statement['proof']}."

    # Generate variants
    short_version = f"{statement['category']}. Finally under control."
    tagline = f"The {statement['category']} for {statement['for_whom']}"

    return {
        "full_statement": full_text,
        "short_version": short_version,
        "tagline": tagline,
        "components": statement,
        "use_cases": {
            "website_headline": short_version,
            "sales_pitch": full_text,
            "elevator_pitch": f"We're the {statement['category']} that gives {statement['for_whom']} {statement['one_thing']}",
            "comparison_page": f"Unlike {statement['competitor']}, we {statement['one_thing']}"
        }
    }
```

---

## 4.2 Representation 2: The Attribute Ladder

**Purpose:** Visual showing you own the top of a single attribute.

**Usage:**
- Customer asks: "How are you different from HubSpot?"
- You show the ladder
- You point: "See? We're here. HubSpot is here. We own [One Thing]. That's the gap."

```python
def generate_attribute_ladder(ladder_data: dict) -> dict:
    """
    Generates the visual ladder with labels and gaps.
    """

    ladder = ladder_data.get("ladder", [])
    attribute = ladder_data.get("attribute", "Strategic Control")

    visual_ladder = []
    for rung in ladder:
        visual_ladder.append({
            "position": rung["position"],
            "label": rung["name"],
            "description": rung["description"],
            "is_you": rung["is_you"],
            "visual_indicator": "★" if rung["is_you"] else "○",
            "css_class": "ladder-top" if rung["is_you"] else "ladder-other"
        })

    return {
        "title": f"The {attribute} Ladder",
        "subtitle": f"Who owns '{attribute}' in the market?",
        "rungs": visual_ladder,
        "your_position": next((r for r in visual_ladder if r["is_you"]), None),
        "defensibility": ladder_data.get("defensibility"),
        "gap_message": ladder_data.get("message"),
        "sales_usage": {
            "objection_handler": f"Unlike competitors lower on the ladder, we own the top because we built the complete {attribute} system",
            "feature_priority": f"Any feature that keeps us at the top of the {attribute} ladder is a priority"
        }
    }
```

---

## 4.3 Representation 3: The Perceptual Map (2x2 Grid)

**Purpose:** Two axes representing attributes that matter to your ICP.

**The Algorithm:**
```python
def generate_perceptual_map(
    foundation: dict,
    status_quo: dict,
    direct: list,
    one_thing: str
) -> dict:
    """
    Derive axes from:
    - X-Axis: Status Quo pain characteristic vs. Your solution
    - Y-Axis: Direct Competitor weakness vs. Your strength

    You plot in the unique quadrant (top-right ideally).
    """

    # Derive X-Axis from Status Quo
    status_quo_pain = status_quo.get("tolerated_pain", "chaos")
    if "random" in status_quo_pain.lower() or "manual" in status_quo_pain.lower():
        x_axis = {"label": "Execution Style", "low": "Random/Manual", "high": "Systematic/Automated"}
    elif "time" in status_quo_pain.lower():
        x_axis = {"label": "Speed", "low": "Time-Consuming", "high": "Fast/Instant"}
    else:
        x_axis = {"label": "Chaos ↔ Control", "low": "Chaos", "high": "Control"}

    # Derive Y-Axis from Direct Competitor weakness
    direct_weakness = direct[0].get("weakness", "complex") if direct else "complex"
    if "complex" in direct_weakness.lower() or "silo" in direct_weakness.lower():
        y_axis = {"label": "Architecture", "low": "Fragmented/Complex", "high": "Unified/Simple"}
    elif "expensive" in direct_weakness.lower():
        y_axis = {"label": "Accessibility", "low": "Enterprise-Only", "high": "Founder-Friendly"}
    else:
        y_axis = {"label": "Intelligence", "low": "Dumb Tools", "high": "AI-Powered"}

    # Plot positions
    positions = [
        {
            "name": status_quo.get("name", "Status Quo"),
            "x": 0.2, "y": 0.2,
            "quadrant": "bottom_left",
            "is_you": False
        },
        {
            "name": direct[0].get("name", "Competitor") if direct else "Competitor",
            "x": 0.7, "y": 0.3,
            "quadrant": "bottom_right",
            "is_you": False
        },
        {
            "name": foundation.get("business_name", "RaptorFlow"),
            "x": 0.85, "y": 0.85,
            "quadrant": "top_right",
            "is_you": True
        }
    ]

    # Define quadrant meanings
    quadrants = {
        "top_right": {
            "label": "The Blue Ocean",
            "description": "Systematic + Unified = Strategic Control",
            "is_target": True
        },
        "top_left": {
            "label": "The Niche Tool",
            "description": "Unified but not systematic",
            "is_target": False
        },
        "bottom_right": {
            "label": "The Enterprise Trap",
            "description": "Systematic but fragmented/complex",
            "is_target": False
        },
        "bottom_left": {
            "label": "The Default/Status Quo",
            "description": "Random and fragmented",
            "is_target": False
        }
    }

    return {
        "x_axis": x_axis,
        "y_axis": y_axis,
        "positions": positions,
        "quadrants": quadrants,
        "your_quadrant": "top_right",
        "strategic_insight": f"You own the {quadrants['top_right']['label']} quadrant where competitors don't play",
        "product_roadmap_guidance": "Stay in your quadrant. Don't drift toward competitor quadrants."
    }
```

---

# 5. DATABASE SCHEMA

## 5.1 Core Tables

### `foundations`
```sql
CREATE TABLE foundations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID REFERENCES tenants(id) ON DELETE CASCADE,

    -- Business Basics
    business_name VARCHAR(255),
    business_type VARCHAR(50),
    industry VARCHAR(100),
    stage VARCHAR(50),
    website_url TEXT,
    offer_statement TEXT,
    price_band VARCHAR(50),
    sales_motion VARCHAR(50),
    team_size VARCHAR(20),
    revenue_model VARCHAR(50)[],

    -- Confessions (THE GOLD)
    confession_expensive_problem TEXT,
    confession_embarrassing_truth TEXT,
    confession_stupid_idea TEXT,
    confession_signaling TEXT,
    confession_friction TEXT,

    -- Cohort Data
    customer_type VARCHAR(50)[],
    buyer_role VARCHAR(255),
    buyer_role_chips VARCHAR(50)[],
    primary_regions VARCHAR(50)[],
    languages VARCHAR(50)[],
    scarf_drivers VARCHAR(50)[],
    decision_style VARCHAR(50),
    risk_tolerance VARCHAR(50),

    -- Customer Insights
    best_customers TEXT[],
    trigger_events VARCHAR(50)[],
    alternatives VARCHAR(50)[], -- CRITICAL FOR UCDA
    pain_ranking TEXT[], -- CRITICAL FOR POSITIONING

    -- Goals & Constraints
    primary_goal VARCHAR(50),
    constraints VARCHAR(50)[],
    current_channels VARCHAR(50)[],
    current_tools VARCHAR(50)[],
    proof_types VARCHAR(50)[], -- CRITICAL FOR PROOF STACK

    -- Positioning (user input)
    category VARCHAR(255),
    target_audience TEXT,
    psychological_outcome TEXT,
    owned_position TEXT,
    reframed_weakness TEXT,

    -- Messaging
    primary_heuristic TEXT,
    belief_pillar TEXT,
    promise_pillar TEXT,
    proof_pillar TEXT,
    voice_preference VARCHAR(50),

    -- Derived Data (AI-populated)
    derived_brand_voice TEXT,
    derived_strategic_pivot TEXT,
    derived_contradictions TEXT[],
    derived_clarity_score REAL,

    context_files TEXT[],
    current_step INT DEFAULT 0,
    completed_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);
```

### `icps`
```sql
CREATE TABLE icps (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID REFERENCES tenants(id) ON DELETE CASCADE,
    foundation_id UUID REFERENCES foundations(id) ON DELETE SET NULL,

    name VARCHAR(255) NOT NULL,
    priority VARCHAR(50) NOT NULL,
    status VARCHAR(50) DEFAULT 'active',
    confidence_score REAL,
    reasoning TEXT,

    firmographics JSONB NOT NULL DEFAULT '{}',
    pain_map JSONB NOT NULL DEFAULT '{}',
    psycholinguistics JSONB NOT NULL DEFAULT '{}',
    disqualifiers JSONB NOT NULL DEFAULT '{}',

    -- Audience-Attribute Fit (Stage 4)
    fit_score REAL,
    fit_breakdown JSONB,

    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);
```

### `competitive_landscape`
```sql
CREATE TABLE competitive_landscape (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID REFERENCES tenants(id) ON DELETE CASCADE,
    foundation_id UUID REFERENCES foundations(id) ON DELETE CASCADE,

    -- UCDA Vectors
    status_quo JSONB NOT NULL,
    indirect_competitors JSONB NOT NULL DEFAULT '[]',
    direct_competitors JSONB NOT NULL DEFAULT '[]',

    -- Gap Analysis (Stage 1)
    gap_analysis JSONB,

    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);
```

### `positioning`
```sql
CREATE TABLE positioning (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID REFERENCES tenants(id) ON DELETE CASCADE,
    foundation_id UUID REFERENCES foundations(id) ON DELETE CASCADE,

    -- Stage 2: Attribute Prioritization
    one_thing VARCHAR(255),
    one_thing_score INT,
    one_thing_breakdown JSONB,

    -- Stage 3: The Attribute Ladder
    attribute_ladder JSONB,
    defensibility VARCHAR(50),
    gap_to_next REAL,

    -- Stage 4: Audience Fit
    primary_icp_id UUID REFERENCES icps(id),
    icp_fit_scores JSONB,

    -- Stage 5: Proof Stack
    proof_stack JSONB,
    proof_gaps TEXT[],

    -- Representation 1: Positioning Statement
    positioning_statement JSONB,

    -- Representation 2: Attribute Ladder (visual)
    ladder_visual JSONB,

    -- Representation 3: Perceptual Map
    perceptual_map JSONB,

    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);
```

### `soundbites`
```sql
CREATE TABLE soundbites (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID REFERENCES tenants(id) ON DELETE CASCADE,
    foundation_id UUID REFERENCES foundations(id) ON DELETE CASCADE,

    one_liner TEXT NOT NULL,
    soundbites JSONB,

    created_at TIMESTAMP DEFAULT NOW()
);
```

---

# 6. API ENDPOINTS

| Method | Endpoint | Description |
|--------|----------|-------------|
| POST | `/api/v1/onboarding/process` | **THE BIG ONE** - Runs full pipeline |
| GET | `/api/v1/foundations` | Get foundation |
| PUT | `/api/v1/foundations` | Update foundation |
| GET | `/api/v1/icps` | List ICPs |
| PUT | `/api/v1/icps/{id}` | Update ICP |
| POST | `/api/v1/icps/regenerate` | Re-run ICP generation |
| GET | `/api/v1/competitive` | Get competitive landscape |
| GET | `/api/v1/positioning` | Get all positioning data |
| GET | `/api/v1/positioning/statement` | Get statement only |
| GET | `/api/v1/positioning/ladder` | Get ladder only |
| GET | `/api/v1/positioning/map` | Get perceptual map only |
| GET | `/api/v1/soundbites` | Get soundbites |
| POST | `/api/v1/positioning/regenerate` | Re-run positioning derivation |

---

# 7. THE 6-NODE LANGGRAPH SPINE

```
__start__ → Architect → Prophet → Strategist → Positioner → Validator → Scribe → __end__
```

### Node 1: Architect
- Validates foundation
- Detects contradictions
- Derives brand voice

### Node 2: Prophet
- Generates 3 emergent ICPs
- Uses SCARF + pain ranking

### Node 3: Strategist
- Runs UCDA algorithm
- Extracts Status Quo, Indirect, Direct

### Node 4: Positioner
- Runs 5-Stage Positioning Derivation
- Generates 3 Representations

### Node 5: Validator
- Runs Stage 4 (Audience-Attribute Fit)
- Runs Stage 5 (Proof Stack)
- Validates overall positioning strength

### Node 6: Scribe
- Generates one-liner
- Creates 7 soundbite types

---

# 8. ENVIRONMENT VARIABLES

```env
DATABASE_URL=postgresql://...
SUPABASE_URL=https://...
SUPABASE_SERVICE_ROLE_KEY=...
GOOGLE_CLOUD_PROJECT=...
GOOGLE_APPLICATION_CREDENTIALS=/path/to/service-account.json
VERTEX_AI_LOCATION=us-central1
INFERENCE_SIMPLE=<vertex-api-key>
```

---

**END OF SPECIFICATION**
