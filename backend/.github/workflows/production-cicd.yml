name: Production CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  release:
    types: [published]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Security and Quality Checks
  security-scan:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run security scan
        uses: securecodewarrior/github-action-add-sarif@v1
        with:
          sarif-file: 'security-scan-results.sarif'

      - name: Run Bandit security linter
        run: |
          pip install bandit
          bandit -r backend/ -f json -o bandit-report.json || true

      - name: Run SAST with CodeQL
        uses: github/codeql-action/analyze@v2
        with:
          languages: python

  # Code Quality Tests
  quality-checks:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install -r backend/requirements.txt
          pip install black isort flake8 mypy pytest

      - name: Run code formatting checks
        run: |
          black --check backend/
          isort --check-only backend/

      - name: Run linting
        run: |
          flake8 backend/ --max-line-length=100 --ignore=E203,W503
          mypy backend/ --ignore-missing-imports

      - name: Run tests with coverage
        run: |
          cd backend
          pytest --cov=. --cov-report=xml --cov-report=html

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./backend/coverage.xml

  # Build and Test Docker Image
  build-test:
    runs-on: ubuntu-latest
    needs: [security-scan, quality-checks]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build test image
        run: |
          docker build -f backend/Dockerfile.production -t raptorflow-test backend/

      - name: Run production readiness tests
        run: |
          docker run --rm \
            -e ENVIRONMENT=test \
            -e SUPABASE_URL=${{ secrets.SUPABASE_TEST_URL }} \
            -e SUPABASE_SERVICE_ROLE_KEY=${{ secrets.SUPABASE_TEST_KEY }} \
            -e UPSTASH_REDIS_URL=${{ secrets.UPSTASH_TEST_URL }} \
            -e UPSTASH_REDIS_TOKEN=${{ secrets.UPSTASH_TEST_TOKEN }} \
            raptorflow-test python tests/production_readiness.py run

      - name: Run load tests
        run: |
          docker run --rm \
            -e ENVIRONMENT=test \
            raptorflow-test python -m pytest tests/load/ -v

  # Security Penetration Testing
  penetration-test:
    runs-on: ubuntu-latest
    needs: build-test
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and run application
        run: |
          docker build -f backend/Dockerfile.production -t raptorflow-pentest backend/
          docker run -d --name pentest-app \
            -p 8080:8080 \
            -e ENVIRONMENT=test \
            -e SUPABASE_URL=${{ secrets.SUPABASE_TEST_URL }} \
            -e SUPABASE_SERVICE_ROLE_KEY=${{ secrets.SUPABASE_TEST_KEY }} \
            -e UPSTASH_REDIS_URL=${{ secrets.UPSTASH_TEST_URL }} \
            -e UPSTASH_REDIS_TOKEN=${{ secrets.UPSTASH_TEST_TOKEN }} \
            raptorflow-pentest

      - name: Wait for application to start
        run: sleep 30

      - name: Run OWASP ZAP Baseline Scan
        uses: zaproxy/action-baseline@v0.7.0
        with:
          target: 'http://localhost:8080'
          rules_file_name: '.zap/rules.tsv'
          cmd_options: '-a'

      - name: Run custom security tests
        run: |
          python tests/security_penetration.py --target http://localhost:8080

      - name: Cleanup
        run: |
          docker stop pentest-app
          docker rm pentest-app

  # Build Production Image
  build-production:
    runs-on: ubuntu-latest
    needs: [build-test, penetration-test]
    if: github.ref == 'refs/heads/main' || github.event_name == 'release'
    outputs:
      image: ${{ steps.image.outputs.image }}
      digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: backend
          file: ./backend/Dockerfile.production
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64

      - name: Output image
        id: image
        run: |
          echo "image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.version }}" >> $GITHUB_OUTPUT

  # Deploy to Staging
  deploy-staging:
    runs-on: ubuntu-latest
    needs: build-production
    if: github.ref == 'refs/heads/develop'
    environment: staging
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up gcloud
        uses: google-github-actions/setup-gcloud@v1
        with:
          version: 'latest'
          service_account_key: ${{ secrets.GCP_SA_KEY }}

      - name: Configure gcloud
        run: |
          gcloud config set project ${{ secrets.GCP_PROJECT_ID }}
          gcloud config set compute/zone ${{ secrets.GCP_ZONE }}

      - name: Deploy to Cloud Run (Staging)
        run: |
          gcloud run deploy raptorflow-backend-staging \
            --image ${{ needs.build-production.outputs.image }} \
            --region ${{ secrets.GCP_REGION }} \
            --platform managed \
            --allow-unauthenticated \
            --memory=1Gi \
            --cpu=1 \
            --timeout=300s \
            --concurrency=1000 \
            --max-instances=10 \
            --min-instances=0 \
            --set-env-vars="ENVIRONMENT=staging" \
            --set-secrets="SUPABASE_URL=supabase-url:latest" \
            --set-secrets="SUPABASE_SERVICE_ROLE_KEY=supabase-key:latest" \
            --set-secrets="UPSTASH_REDIS_URL=redis-url:latest" \
            --set-secrets="UPSTASH_REDIS_TOKEN=redis-token:latest" \
            --set-secrets="JWT_SECRET_KEY=jwt-secret:latest"

      - name: Run smoke tests
        run: |
          python tests/smoke_tests.py --environment staging

  # Deploy to Production
  deploy-production:
    runs-on: ubuntu-latest
    needs: build-production
    if: github.event_name == 'release'
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up gcloud
        uses: google-github-actions/setup-gcloud@v1
        with:
          version: 'latest'
          service_account_key: ${{ secrets.GCP_SA_KEY }}

      - name: Configure gcloud
        run: |
          gcloud config set project ${{ secrets.GCP_PROJECT_ID }}
          gcloud config set compute/zone ${{ secrets.GCP_ZONE }}

      - name: Deploy to Cloud Run (Production)
        run: |
          gcloud run deploy raptorflow-backend \
            --image ${{ needs.build-production.outputs.image }} \
            --region ${{ secrets.GCP_REGION }} \
            --platform managed \
            --allow-unauthenticated \
            --memory=2Gi \
            --cpu=2 \
            --timeout=300s \
            --concurrency=1000 \
            --max-instances=100 \
            --min-instances=1 \
            --set-env-vars="ENVIRONMENT=production" \
            --set-env-vars="ENABLE_RATE_LIMITING=true" \
            --set-env-vars="ENABLE_COMPRESSION=true" \
            --set-secrets="SUPABASE_URL=supabase-url:latest" \
            --set-secrets="SUPABASE_SERVICE_ROLE_KEY=supabase-key:latest" \
            --set-secrets="UPSTASH_REDIS_URL=redis-url:latest" \
            --set-secrets="UPSTASH_REDIS_TOKEN=redis-token:latest" \
            --set-secrets="JWT_SECRET_KEY=jwt-secret:latest" \
            --set-secrets="SENTRY_DSN=sentry-dsn:latest"

      - name: Configure auto-scaling
        run: |
          gcloud run services update-traffic raptorflow-backend \
            --region ${{ secrets.GCP_REGION }} \
            --to-latest-revisions

      - name: Run production smoke tests
        run: |
          python tests/smoke_tests.py --environment production

      - name: Update monitoring
        run: |
          python scripts/update_monitoring.py --environment production

  # Post-deployment Tests
  post-deployment-tests:
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: github.event_name == 'release'
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run comprehensive health checks
        run: |
          python tests/comprehensive_health_checks.py --environment production

      - name: Run performance tests
        run: |
          python tests/performance_tests.py --environment production --duration 300

      - name: Verify monitoring
        run: |
          python tests/monitoring_verification.py --environment production

      - name: Generate deployment report
        run: |
          python scripts/generate_deployment_report.py \
            --environment production \
            --version ${{ github.ref_name }}

      - name: Upload deployment report
        uses: actions/upload-artifact@v3
        with:
          name: deployment-report
          path: deployment-report.json

  # Rollback on Failure
  rollback:
    runs-on: ubuntu-latest
    needs: [deploy-production, post-deployment-tests]
    if: failure() && needs.deploy-production.result == 'success'
    environment: production
    steps:
      - name: Set up gcloud
        uses: google-github-actions/setup-gcloud@v1
        with:
          version: 'latest'
          service_account_key: ${{ secrets.GCP_SA_KEY }}

      - name: Configure gcloud
        run: |
          gcloud config set project ${{ secrets.GCP_PROJECT_ID }}
          gcloud config set compute/zone ${{ secrets.GCP_ZONE }}

      - name: Rollback to previous version
        run: |
          # Get previous revision
          PREVIOUS_REVISION=$(gcloud run services revisions list raptorflow-backend \
            --region ${{ secrets.GCP_REGION }} \
            --limit=2 \
            --format="value(REVISION)" | tail -1)
          
          # Rollback to previous revision
          gcloud run services update-traffic raptorflow-backend \
            --region ${{ secrets.GCP_REGION }} \
            --to-revisions=$PREVIOUS_REVISION=100

      - name: Notify team
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          channel: '#deployments'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
          text: 'üö® Production deployment rolled back due to test failures'

  # Notification
  notify:
    runs-on: ubuntu-latest
    needs: [deploy-production, post-deployment-tests]
    if: always()
    steps:
      - name: Notify success
        if: needs.deploy-production.result == 'success' && needs.post-deployment-tests.result == 'success'
        uses: 8398a7/action-slack@v3
        with:
          status: success
          channel: '#deployments'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
          text: '‚úÖ Production deployment successful!'

      - name: Notify failure
        if: needs.deploy-production.result == 'failure' || needs.post-deployment-tests.result == 'failure'
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          channel: '#deployments'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
          text: '‚ùå Production deployment failed!'
