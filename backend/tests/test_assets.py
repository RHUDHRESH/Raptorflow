import asyncio
import json
from datetime import datetime
from typing import Any, Dict
from unittest.mock import AsyncMock, patch
from uuid import uuid4

import pytest
from fastapi.testclient import TestClient
from httpx import AsyncClient

from main import app
from models.asset_models import AssetCreate, AssetResponse, AssetUpdate
from services.asset_service import AssetService


class TestAssetCRUD:
    """Test suite for Asset CRUD operations."""

    @pytest.fixture
    def client(self):
        """Create a test client."""
        return TestClient(app)

    @pytest.fixture
    async def test_workspace_id(self):
        """Test workspace ID."""
        return uuid4()

    @pytest.fixture
    async def test_user(self):
        """Test user data."""
        return {
            "id": uuid4(),
            "email": "test@example.com",
            "role": "founder"
        }

    @pytest.fixture
    def sample_asset_data(self):
        """Sample asset data for testing."""
        return {
            "title": "Test Email Campaign",
            "content": "This is a test email content for our campaign.",
            "asset_type": "email",
            "folder": "campaigns",
            "prompt": "Generate a marketing email for product launch",
            "status": "draft",
            "tags": ["marketing", "email", "campaign"],
            "metadata": {"campaign_id": "camp_123", "target_audience": "enterprise"}
        }

    @pytest.fixture
    def sample_asset_create(self, sample_asset_data):
        """Sample AssetCreate object."""
        return AssetCreate(**sample_asset_data)

    @pytest.fixture
    def sample_asset_response(self, sample_asset_data, test_workspace_id):
        """Sample AssetResponse object."""
        return AssetResponse(
            id=uuid4(),
            workspace_id=test_workspace_id,
            **sample_asset_data,
            version=1,
            is_deleted=False,
            created_at=datetime.utcnow(),
            updated_at=datetime.utcnow()
        )

    @pytest.mark.asyncio
    async def test_create_asset_success(self, sample_asset_create, test_workspace_id):
        """Test successful asset creation."""
        with patch('services.asset_service.get_db_connection') as mock_conn:
            mock_cursor = AsyncMock()
            mock_conn.return_value.__aenter__.return_value.cursor.return_value.__aenter__.return_value = mock_cursor

            # Mock the database response
            mock_cursor.fetchone.return_value = (
                uuid4(),  # id
                1,        # version
                False,    # is_deleted
                datetime.utcnow(),  # created_at
                datetime.utcnow(),  # updated_at
                None,     # deleted_at
                0.85,     # quality_score
                sample_asset_create.prompt,  # generation_prompt
                "gpt-4",  # generation_model
                1500      # generation_tokens
            )

            result = await AssetService.create_asset(test_workspace_id, sample_asset_create)

            assert isinstance(result, AssetResponse)
            assert result.title == sample_asset_create.title
            assert result.content == sample_asset_create.content
            assert result.asset_type == sample_asset_create.asset_type
            assert result.workspace_id == test_workspace_id
            assert result.version == 1
            assert result.is_deleted is False

    @pytest.mark.asyncio
    async def test_create_asset_with_speed_daemon(self, sample_asset_create, test_workspace_id):
        """Test asset creation with Speed Daemon auto-generation."""
        sample_asset_create.use_speed_daemon = True

        with patch('services.asset_service.get_db_connection') as mock_conn, \
             patch.object(AssetService, '_call_windsurf_service') as mock_windsurf:

            mock_cursor = AsyncMock()
            mock_conn.return_value.__aenter__.return_value.cursor.return_value.__aenter__.return_value = mock_cursor
            mock_windsurf.return_value = "[Auto-generated by Speed Daemon] Enhanced content"

            mock_cursor.fetchone.return_value = (
                uuid4(), 1, False, datetime.utcnow(), datetime.utcnow(),
                None, 0.90, sample_asset_create.prompt, "gpt-4", 1600
            )

            result = await AssetService.create_asset(test_workspace_id, sample_asset_create)

            assert result.content == "[Auto-generated by Speed Daemon] Enhanced content"
            mock_windsurf.assert_called_once_with(sample_asset_create)

    @pytest.mark.asyncio
    async def test_get_assets_with_filters(self, test_workspace_id):
        """Test getting assets with various filters."""
        from models.asset_models import AssetSearchParams

        search_params = AssetSearchParams(
            type="email",
            folder="campaigns",
            status="draft",
            search_text="marketing",
            page=1,
            page_size=10
        )

        with patch('services.asset_service.get_db_connection') as mock_conn:
            mock_cursor = AsyncMock()
            mock_conn.return_value.__aenter__.return_value.cursor.return_value.__aenter__.return_value = mock_cursor

            # Mock count query
            mock_cursor.fetchone.side_effect = [
                (5,),  # total count
                (  # asset data
                    uuid4(), "Test Email", "Content", "email", "campaigns", "prompt", "draft",
                    ["marketing"], {}, 1, False, datetime.utcnow(), datetime.utcnow(),
                    None, 0.85, "prompt", "gpt-4", 1500
                )
            ]

            assets, total = await AssetService.get_assets(test_workspace_id, search_params)

            assert total == 5
            assert len(assets) == 1
            assert assets[0].asset_type == "email"
            assert assets[0].folder == "campaigns"

    @pytest.mark.asyncio
    async def test_get_asset_by_id_success(self, test_workspace_id):
        """Test getting a single asset by ID."""
        asset_id = uuid4()

        with patch('services.asset_service.get_db_connection') as mock_conn:
            mock_cursor = AsyncMock()
            mock_conn.return_value.__aenter__.return_value.cursor.return_value.__aenter__.return_value = mock_cursor

            mock_cursor.fetchone.return_value = (
                asset_id, "Test Email", "Content", "email", "campaigns", "prompt", "draft",
                ["marketing"], {}, 1, False, datetime.utcnow(), datetime.utcnow(),
                None, 0.85, "prompt", "gpt-4", 1500
            )

            result = await AssetService.get_asset_by_id(test_workspace_id, asset_id)

            assert result is not None
            assert result.id == asset_id
            assert result.title == "Test Email"

    @pytest.mark.asyncio
    async def test_get_asset_by_id_not_found(self, test_workspace_id):
        """Test getting a non-existent asset."""
        asset_id = uuid4()

        with patch('services.asset_service.get_db_connection') as mock_conn:
            mock_cursor = AsyncMock()
            mock_conn.return_value.__aenter__.return_value.cursor.return.return_value.__aenter__.return_value = mock_cursor
            mock_cursor.fetchone.return_value = None

            result = await AssetService.get_asset_by_id(test_workspace_id, asset_id)

            assert result is None

    @pytest.mark.asyncio
    async def test_update_asset_success(self, test_workspace_id):
        """Test successful asset update."""
        asset_id = uuid4()
        update_data = AssetUpdate(
            title="Updated Email Campaign",
            content="Updated content",
            version=1
        )

        with patch('services.asset_service.get_db_connection') as mock_conn:
            mock_cursor = AsyncMock()
            mock_conn.return_value.__aenter__.return_value.cursor.return_value.__aenter__.return_value = mock_cursor

            # Mock current asset query
            mock_cursor.fetchone.side_effect = [
                (1, False),  # current version and is_deleted
                (  # updated asset data
                    asset_id, "Updated Email Campaign", "Updated content", "email", "campaigns",
                    "prompt", "draft", ["marketing"], {}, 2, False, datetime.utcnow(),
                    datetime.utcnow(), None, 0.85, "prompt", "gpt-4", 1500
                )
            ]

            result = await AssetService.update_asset(test_workspace_id, asset_id, update_data)

            assert result.title == "Updated Email Campaign"
            assert result.content == "Updated content"
            assert result.version == 2

    @pytest.mark.asyncio
    async def test_update_asset_optimistic_locking_failure(self, test_workspace_id):
        """Test update failure due to optimistic locking."""
        asset_id = uuid4()
        update_data = AssetUpdate(title="Updated", version=2)  # Wrong version

        with patch('services.asset_service.get_db_connection') as mock_conn:
            mock_cursor = AsyncMock()
            mock_conn.return_value.__aenter__.return_value.cursor.return.return_value.__aenter__.return_value = mock_cursor

            # Mock current asset with different version
            mock_cursor.fetchone.return_value = (1, False)  # version 1, not deleted

            from core.exceptions import RaptorFlowError
            with pytest.raises(RaptorFlowError) as exc_info:
                await AssetService.update_asset(test_workspace_id, asset_id, update_data)

            assert "has been modified by another user" in str(exc_info.value)

    @pytest.mark.asyncio
    async def test_update_asset_not_found(self, test_workspace_id):
        """Test updating a non-existent asset."""
        asset_id = uuid4()
        update_data = AssetUpdate(title="Updated")

        with patch('services.asset_service.get_db_connection') as mock_conn:
            mock_cursor = AsyncMock()
            mock_conn.return_value.__aenter__.return_value.cursor.return.return_value.__aenter__.return_value = mock_cursor
            mock_cursor.fetchone.return_value = None

            from core.exceptions import RaptorFlowError
            with pytest.raises(RaptorFlowError) as exc_info:
                await AssetService.update_asset(test_workspace_id, asset_id, update_data)

            assert "not found" in str(exc_info.value).lower()

    @pytest.mark.asyncio
    async def test_delete_asset_success(self, test_workspace_id):
        """Test successful asset soft delete."""
        asset_id = uuid4()

        with patch('services.asset_service.get_db_connection') as mock_conn:
            mock_cursor = AsyncMock()
            mock_conn.return_value.__aenter__.return_value.cursor.return.return_value.__aenter__.return_value = mock_cursor
            mock_cursor.rowcount = 1  # One row affected

            result = await AssetService.delete_asset(test_workspace_id, asset_id)

            assert result is True

    @pytest.mark.asyncio
    async def test_delete_asset_not_found(self, test_workspace_id):
        """Test deleting a non-existent asset."""
        asset_id = uuid4()

        with patch('services.asset_service.get_db_connection') as mock_conn:
            mock_cursor = AsyncMock()
            mock_conn.return_value.__aenter__.return_value.cursor.return.return_value.__aenter__.return_value = mock_cursor
            mock_cursor.rowcount = 0  # No rows affected

            result = await AssetService.delete_asset(test_workspace_id, asset_id)

            assert result is False

    @pytest.mark.asyncio
    async def test_duplicate_asset_success(self, test_workspace_id):
        """Test successful asset duplication."""
        asset_id = uuid4()
        original_asset = AssetResponse(
            id=asset_id,
            workspace_id=test_workspace_id,
            title="Original Asset",
            content="Original content",
            asset_type="email",
            folder="campaigns",
            version=1,
            is_deleted=False,
            created_at=datetime.utcnow(),
            updated_at=datetime.utcnow()
        )

        with patch.object(AssetService, 'get_asset_by_id') as mock_get, \
             patch.object(AssetService, 'create_asset') as mock_create:

            mock_get.return_value = original_asset
            mock_create.return_value = AssetResponse(
                id=uuid4(),
                workspace_id=test_workspace_id,
                title="Original Asset (Copy)",
                content="Original content",
                asset_type="email",
                folder="campaigns",
                version=1,
                is_deleted=False,
                created_at=datetime.utcnow(),
                updated_at=datetime.utcnow()
            )

            result = await AssetService.duplicate_asset(test_workspace_id, asset_id)

            assert result.title == "Original Asset (Copy)"
            assert result.content == original_asset.content
            mock_get.assert_called_once_with(test_workspace_id, asset_id)

    @pytest.mark.asyncio
    async def test_duplicate_asset_not_found(self, test_workspace_id):
        """Test duplicating a non-existent asset."""
        asset_id = uuid4()

        with patch.object(AssetService, 'get_asset_by_id') as mock_get:
            mock_get.return_value = None

            from core.exceptions import RaptorFlowError
            with pytest.raises(RaptorFlowError) as exc_info:
                await AssetService.duplicate_asset(test_workspace_id, asset_id)

            assert "not found" in str(exc_info.value).lower()


class TestAssetAPIEndpoints:
    """Test suite for Asset API endpoints."""

    @pytest.fixture
    def client(self):
        """Create a test client."""
        return TestClient(app)

    @pytest.fixture
    def mock_auth_headers(self):
        """Mock authentication headers."""
        return {"Authorization": "Bearer test_token"}

    def test_list_assets_endpoint(self, client, mock_auth_headers):
        """Test GET /assets endpoint."""
        with patch('api.v1.assets.AssetService.get_assets') as mock_get:
            mock_get.return_value = ([], 0)

            response = client.get("/v1/assets", headers=mock_auth_headers)

            assert response.status_code == 200
            data = response.json()
            assert "assets" in data
            assert "total" in data
            assert "page" in data

    def test_create_asset_endpoint(self, client, mock_auth_headers, sample_asset_data):
        """Test POST /assets endpoint."""
        with patch('api.v1.assets.AssetService.create_asset') as mock_create:
            mock_create.return_value = AssetResponse(
                id=uuid4(),
                workspace_id=uuid4(),
                **sample_asset_data,
                version=1,
                is_deleted=False,
                created_at=datetime.utcnow(),
                updated_at=datetime.utcnow()
            )

            response = client.post("/v1/assets", json=sample_asset_data, headers=mock_auth_headers)

            assert response.status_code == 201
            data = response.json()
            assert data["title"] == sample_asset_data["title"]
            assert data["asset_type"] == sample_asset_data["asset_type"]

    def test_get_asset_endpoint(self, client, mock_auth_headers):
        """Test GET /assets/{asset_id} endpoint."""
        asset_id = uuid4()

        with patch('api.v1.assets.AssetService.get_asset_by_id') as mock_get:
            mock_get.return_value = None  # Asset not found

            response = client.get(f"/v1/assets/{asset_id}", headers=mock_auth_headers)

            assert response.status_code == 404

    def test_update_asset_endpoint(self, client, mock_auth_headers):
        """Test PUT /assets/{asset_id} endpoint."""
        asset_id = uuid4()
        update_data = {"title": "Updated Title"}

        with patch('api.v1.assets.AssetService.update_asset') as mock_update:
            mock_update.side_effect = Exception("Asset not found")

            response = client.put(f"/v1/assets/{asset_id}", json=update_data, headers=mock_auth_headers)

            assert response.status_code == 500

    def test_delete_asset_endpoint(self, client, mock_auth_headers):
        """Test DELETE /assets/{asset_id} endpoint."""
        asset_id = uuid4()

        with patch('api.v1.assets.AssetService.delete_asset') as mock_delete:
            mock_delete.return_value = False  # Asset not found

            response = client.delete(f"/v1/assets/{asset_id}", headers=mock_auth_headers)

            assert response.status_code == 404

    def test_duplicate_asset_endpoint(self, client, mock_auth_headers):
        """Test POST /assets/{asset_id}/duplicate endpoint."""
        asset_id = uuid4()

        with patch('api.v1.assets.AssetService.duplicate_asset') as mock_duplicate:
            mock_duplicate.side_effect = Exception("Asset not found")

            response = client.post(f"/v1/assets/{asset_id}/duplicate", headers=mock_auth_headers)

            assert response.status_code == 500


class TestAssetValidation:
    """Test suite for asset validation."""

    def test_valid_asset_types(self):
        """Test validation of allowed asset types."""
        valid_types = [
            'email', 'tagline', 'social-post', 'ad-copy',
            'landing-page', 'blog-post', 'press-release',
            'video-script', 'image-prompt', 'other'
        ]

        for asset_type in valid_types:
            asset_data = AssetCreate(
                title="Test",
                content="Test content",
                asset_type=asset_type
            )
            assert asset_data.asset_type == asset_type

    def test_invalid_asset_type(self):
        """Test validation of invalid asset type."""
        with pytest.raises(ValueError) as exc_info:
            AssetCreate(
                title="Test",
                content="Test content",
                asset_type="invalid-type"
            )

        assert "Asset type must be one of" in str(exc_info.value)

    def test_valid_statuses(self):
        """Test validation of allowed statuses."""
        valid_statuses = ['draft', 'ready', 'archived', 'deleted']

        for status in valid_statuses:
            asset_data = AssetCreate(
                title="Test",
                content="Test content",
                asset_type="email",
                status=status
            )
            assert asset_data.status == status

    def test_invalid_status(self):
        """Test validation of invalid status."""
        with pytest.raises(ValueError) as exc_info:
            AssetCreate(
                title="Test",
                content="Test content",
                asset_type="email",
                status="invalid-status"
            )

        assert "Status must be one of" in str(exc_info.value)

    def test_title_validation(self):
        """Test title length validation."""
        # Test empty title
        with pytest.raises(ValueError):
            AssetCreate(
                title="",
                content="Test content",
                asset_type="email"
            )

        # Test title too long
        with pytest.raises(ValueError):
            AssetCreate(
                title="x" * 256,  # 256 characters, exceeds max 255
                content="Test content",
                asset_type="email"
            )

    def test_content_validation(self):
        """Test content validation."""
        # Test empty content
        with pytest.raises(ValueError):
            AssetCreate(
                title="Test",
                content="",
                asset_type="email"
            )


class TestLegacyLogoUpload:
    """Test suite for legacy logo upload functionality."""

    def test_upload_logo_success(self):
        """Tests successful logo upload with mocking GCS."""
        file_content = b"fake-image-content"
        file_name = "test_logo.png"

        # Mock BrandAssetManager.upload_logo
        with patch("backend.api.v1.assets.BrandAssetManager.upload_logo") as mock_upload:
            mock_upload.return_value = (
                "https://storage.googleapis.com/test-bucket/assets/logos/test_logo.png"
            )

            client = TestClient(app)
            response = client.post(
                "/v1/assets/upload-logo",
                files={"file": (file_name, file_content, "image/png")},
            )

            assert response.status_code == 200
            assert response.json()["url"] == mock_upload.return_value
            assert response.json()["status"] == "success"
            mock_upload.assert_called_once()

    def test_upload_logo_invalid_type(self):
        """Tests rejection of invalid file types."""
        client = TestClient(app)
        response = client.post(
            "/v1/assets/upload-logo", files={"file": ("test.txt", b"hello", "text/plain")}
        )
        assert response.status_code == 400
        assert "Unsupported file type" in response.json()["detail"]


if __name__ == "__main__":
    # Run the tests
    pytest.main([__file__, "-v"])
