import { z } from 'zod'; import { BaseOrchestratorAgent, AgentManifest, AgentInput, AgentOutput } from './base';
const SalesTalkingPointsSchema = z.object({ points: z.array(z.object({ point: z.string(), objection: z.string(), response: z.string() })) });
const manifest: AgentManifest = { name: 'SalesTalkingPoints', description: 'Creates sales talking points and objection handling', version: '1.0.0', category: 'marketing', inputs: { required: ['brandProfileId'], optional: ['inputOverrides', 'contextSnapshot'] }, outputs: { type: 'SalesTalkingPoints', format: 'json', schema: SalesTalkingPointsSchema }, capabilities: ['Sales strategy', 'Objection handling'], costEstimate: { minTokens: 300, maxTokens: 700, estimatedCost: 0.009 }, connectors: [], metadata: { author: 'system', tags: ['sales', 'talking-points'], complexity: 'medium' } };
export class SalesTalkingPointsAgent extends BaseOrchestratorAgent { constructor() { super(manifest); } async generate(input: AgentInput): Promise<AgentOutput> { const validation = this.validateInput(input); if (!validation.valid) throw new Error(`Invalid input: ${validation.errors.join(', ')}`); const context = await this.getContext(input); const prompt = await this.renderPrompt(context, input); const { content, metadata } = await this.generateLLMRequest(prompt, input); return this.processOutput(content, metadata); } }
export const salesTalkingPointsAgent = new SalesTalkingPointsAgent(); export { manifest as salesTalkingPointsManifest }; export type SalesTalkingPointsOutput = z.infer<typeof SalesTalkingPointsSchema>;

