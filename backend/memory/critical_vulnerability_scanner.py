#!/usr/bin/env python3
"""
üî• CRITICAL VULNERABILITY SCANNER üî•
Find the most critical vulnerabilities that could actually break the system.
"""

import json
import os
import sys
import traceback
from datetime import datetime
from typing import Any, Dict, List, Optional

# Add the memory directory to path
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

try:
    from graph_models import (
        EntityType,
        GraphEntity,
        GraphRelationship,
        RelationType,
        SubGraph,
    )
    from models import MemoryChunk, MemoryType
except ImportError as e:
    print(f"‚ùå Import failed: {e}")
    sys.exit(1)


class CriticalVulnerabilityScanner:
    """Scan for critical vulnerabilities that actually matter."""

    def __init__(self):
        self.vulnerabilities = []
        self.warnings = []
        self.passed = []

    def log_vulnerability(self, test_name: str, description: str):
        """Log a vulnerability."""
        self.vulnerabilities.append({"test": test_name, "description": description})
        print(f"üö® CRITICAL VULNERABILITY in {test_name}: {description}")

    def log_warning(self, test_name: str, description: str):
        """Log a warning."""
        self.warnings.append({"test": test_name, "description": description})
        print(f"‚ö†Ô∏è WARNING in {test_name}: {description}")

    def log_pass(self, test_name: str, description: str):
        """Log a passed test."""
        self.passed.append({"test": test_name, "description": description})
        print(f"‚úÖ PASSED {test_name}: {description}")

    def test_1_critical_input_validation(self):
        """Test critical input validation failures."""
        print("\nüîç Test 1: Critical Input Validation")

        try:
            # Test None values in critical fields
            critical_none_tests = [
                # MemoryChunk with None in critical fields
                lambda: MemoryChunk(
                    id=None,
                    workspace_id="test",
                    content="test",
                    memory_type=MemoryType.FOUNDATION,
                ),
                lambda: MemoryChunk(
                    id="test",
                    workspace_id=None,
                    content="test",
                    memory_type=MemoryType.FOUNDATION,
                ),
                lambda: MemoryChunk(
                    id="test",
                    workspace_id="test",
                    content=None,
                    memory_type=MemoryType.FOUNDATION,
                ),
                # GraphEntity with None in critical fields
                lambda: GraphEntity(
                    id=None,
                    workspace_id="test",
                    entity_type=EntityType.COMPANY,
                    name="test",
                ),
                lambda: GraphEntity(
                    id="test",
                    workspace_id=None,
                    entity_type=EntityType.COMPANY,
                    name="test",
                ),
                lambda: GraphEntity(
                    id="test", workspace_id="test", entity_type=None, name="test"
                ),
                # GraphRelationship with None in critical fields
                lambda: GraphRelationship(
                    id=None,
                    workspace_id="test",
                    source_id="e1",
                    target_id="e2",
                    relation_type=RelationType.RELATED_TO,
                ),
                lambda: GraphRelationship(
                    id="test",
                    workspace_id=None,
                    source_id="e1",
                    target_id="e2",
                    relation_type=RelationType.RELATED_TO,
                ),
                lambda: GraphRelationship(
                    id="test",
                    workspace_id="test",
                    source_id=None,
                    target_id="e2",
                    relation_type=RelationType.RELATED_TO,
                ),
                lambda: GraphRelationship(
                    id="test",
                    workspace_id="test",
                    source_id="e1",
                    target_id=None,
                    relation_type=RelationType.RELATED_TO,
                ),
                lambda: GraphRelationship(
                    id="test",
                    workspace_id="test",
                    source_id="e1",
                    target_id="e2",
                    relation_type=None,
                ),
            ]

            for i, test_func in enumerate(critical_none_tests):
                try:
                    result = test_func()
                    # If it succeeds, check if it handles None properly
                    if result and hasattr(result, "is_valid"):
                        if result.is_valid():
                            self.log_vulnerability(
                                "INPUT_VALIDATION",
                                f"Test {i+1}: None value accepted as valid",
                            )
                        else:
                            self.log_pass(
                                "INPUT_VALIDATION",
                                f"Test {i+1}: None value properly rejected",
                            )
                    else:
                        self.log_warning(
                            "INPUT_VALIDATION", f"Test {i+1}: No validation method"
                        )
                except Exception as e:
                    self.log_pass(
                        "INPUT_VALIDATION",
                        f"Test {i+1}: None value rejected with exception: {type(e).__name__}",
                    )

        except Exception as e:
            self.log_vulnerability("INPUT_VALIDATION", f"Test failed: {e}")

    def test_2_critical_type_safety(self):
        """Test critical type safety violations."""
        print("\nüîç Test 2: Critical Type Safety")

        try:
            # Test wrong types that could break the system
            type_violation_tests = [
                # MemoryChunk with wrong types
                lambda: MemoryChunk(
                    id=123,
                    workspace_id="test",
                    content="test",
                    memory_type=MemoryType.FOUNDATION,
                ),  # int id
                lambda: MemoryChunk(
                    id="test",
                    workspace_id=123,
                    content="test",
                    memory_type=MemoryType.FOUNDATION,
                ),  # int workspace
                lambda: MemoryChunk(
                    id="test",
                    workspace_id="test",
                    content=123,
                    memory_type=MemoryType.FOUNDATION,
                ),  # int content
                lambda: MemoryChunk(
                    id="test",
                    workspace_id="test",
                    content="test",
                    memory_type="INVALID",
                ),  # string memory_type
                # GraphEntity with wrong types
                lambda: GraphEntity(
                    id=123,
                    workspace_id="test",
                    entity_type=EntityType.COMPANY,
                    name="test",
                ),  # int id
                lambda: GraphEntity(
                    id="test",
                    workspace_id=123,
                    entity_type=EntityType.COMPANY,
                    name="test",
                ),  # int workspace
                lambda: GraphEntity(
                    id="test", workspace_id="test", entity_type="INVALID", name="test"
                ),  # string entity_type
                lambda: GraphEntity(
                    id="test",
                    workspace_id="test",
                    entity_type=EntityType.COMPANY,
                    name=123,
                ),  # int name
                # GraphRelationship with wrong types
                lambda: GraphRelationship(
                    id=123,
                    workspace_id="test",
                    source_id="e1",
                    target_id="e2",
                    relation_type=RelationType.RELATED_TO,
                ),  # int id
                lambda: GraphRelationship(
                    id="test",
                    workspace_id=123,
                    source_id="e1",
                    target_id="e2",
                    relation_type=RelationType.RELATED_TO,
                ),  # int workspace
                lambda: GraphRelationship(
                    id="test",
                    workspace_id="test",
                    source_id=123,
                    target_id="e2",
                    relation_type=RelationType.RELATED_TO,
                ),  # int source_id
                lambda: GraphRelationship(
                    id="test",
                    workspace_id="test",
                    source_id="e1",
                    target_id=123,
                    relation_type=RelationType.RELATED_TO,
                ),  # int target_id
                lambda: GraphRelationship(
                    id="test",
                    workspace_id="test",
                    source_id="e1",
                    target_id="e2",
                    relation_type="INVALID",
                ),  # string relation_type
                lambda: GraphRelationship(
                    id="test",
                    workspace_id="test",
                    source_id="e1",
                    target_id="e2",
                    relation_type=RelationType.RELATED_TO,
                    weight="invalid",
                ),  # string weight
            ]

            for i, test_func in enumerate(type_violation_tests):
                try:
                    result = test_func()
                    # If it succeeds, check if it handles type violations properly
                    if result and hasattr(result, "is_valid"):
                        if result.is_valid():
                            self.log_vulnerability(
                                "TYPE_SAFETY",
                                f"Test {i+1}: Type violation accepted as valid",
                            )
                        else:
                            self.log_pass(
                                "TYPE_SAFETY",
                                f"Test {i+1}: Type violation properly rejected",
                            )
                    else:
                        self.log_warning(
                            "TYPE_SAFETY", f"Test {i+1}: No validation method"
                        )
                except Exception as e:
                    self.log_pass(
                        "TYPE_SAFETY",
                        f"Test {i+1}: Type violation rejected with exception: {type(e).__name__}",
                    )

        except Exception as e:
            self.log_vulnerability("TYPE_SAFETY", f"Test failed: {e}")

    def test_3_critical_boundary_conditions(self):
        """Test critical boundary conditions."""
        print("\nüîç Test 3: Critical Boundary Conditions")

        try:
            # Test boundary conditions that could break the system
            boundary_tests = [
                # Empty strings
                lambda: MemoryChunk(
                    id="",
                    workspace_id="test",
                    content="test",
                    memory_type=MemoryType.FOUNDATION,
                ),
                lambda: GraphEntity(
                    id="",
                    workspace_id="test",
                    entity_type=EntityType.COMPANY,
                    name="test",
                ),
                lambda: GraphRelationship(
                    id="",
                    workspace_id="test",
                    source_id="e1",
                    target_id="e2",
                    relation_type=RelationType.RELATED_TO,
                ),
                # Very long strings
                lambda: MemoryChunk(
                    id="x" * 10000,
                    workspace_id="test",
                    content="test",
                    memory_type=MemoryType.FOUNDATION,
                ),
                lambda: GraphEntity(
                    id="test",
                    workspace_id="x" * 10000,
                    entity_type=EntityType.COMPANY,
                    name="test",
                ),
                lambda: GraphRelationship(
                    id="test",
                    workspace_id="test",
                    source_id="x" * 10000,
                    target_id="e2",
                    relation_type=RelationType.RELATED_TO,
                ),
                # Special characters
                lambda: MemoryChunk(
                    id="test\x00\x01\x02",
                    workspace_id="test",
                    content="test",
                    memory_type=MemoryType.FOUNDATION,
                ),
                lambda: GraphEntity(
                    id="test",
                    workspace_id="test\x00\x01\x02",
                    entity_type=EntityType.COMPANY,
                    name="test",
                ),
                lambda: GraphRelationship(
                    id="test",
                    workspace_id="test",
                    source_id="test\x00\x01\x02",
                    target_id="e2",
                    relation_type=RelationType.RELATED_TO,
                ),
                # Unicode edge cases
                lambda: MemoryChunk(
                    id="testüî•üíÄüö®",
                    workspace_id="test",
                    content="test",
                    memory_type=MemoryType.FOUNDATION,
                ),
                lambda: GraphEntity(
                    id="test",
                    workspace_id="testüî•üíÄüö®",
                    entity_type=EntityType.COMPANY,
                    name="test",
                ),
                lambda: GraphRelationship(
                    id="test",
                    workspace_id="test",
                    source_id="testüî•üíÄüö®",
                    target_id="e2",
                    relation_type=RelationType.RELATED_TO,
                ),
            ]

            for i, test_func in enumerate(boundary_tests):
                try:
                    result = test_func()
                    # If it succeeds, check if it handles boundaries properly
                    if result and hasattr(result, "is_valid"):
                        if result.is_valid():
                            self.log_warning(
                                "BOUNDARY_CONDITION",
                                f"Test {i+1}: Boundary condition accepted",
                            )
                        else:
                            self.log_pass(
                                "BOUNDARY_CONDITION",
                                f"Test {i+1}: Boundary condition properly rejected",
                            )
                    else:
                        self.log_warning(
                            "BOUNDARY_CONDITION", f"Test {i+1}: No validation method"
                        )
                except Exception as e:
                    self.log_pass(
                        "BOUNDARY_CONDITION",
                        f"Test {i+1}: Boundary condition rejected with exception: {type(e).__name__}",
                    )

        except Exception as e:
            self.log_vulnerability("BOUNDARY_CONDITION", f"Test failed: {e}")

    def test_4_critical_serialization_attacks(self):
        """Test critical serialization attacks."""
        print("\nüîç Test 4: Critical Serialization Attacks")

        try:
            # Test serialization attacks that could break the system
            serialization_tests = [
                # Circular references
                lambda: self.test_circular_reference(),
                # Very deep nesting
                lambda: self.test_deep_nesting(),
                # Malicious JSON
                lambda: self.test_malicious_json(),
            ]

            for i, test_func in enumerate(serialization_tests):
                try:
                    test_func()
                    self.log_pass(
                        "SERIALIZATION_ATTACKS",
                        f"Test {i+1}: Serialization attack handled",
                    )
                except Exception as e:
                    self.log_vulnerability(
                        "SERIALIZATION_ATTACKS",
                        f"Test {i+1}: Serialization attack broke system: {e}",
                    )

        except Exception as e:
            self.log_vulnerability("SERIALIZATION_ATTACKS", f"Test failed: {e}")

    def test_circular_reference(self):
        """Test circular reference handling."""
        # Create a circular reference
        data = {}
        data["self"] = data

        try:
            chunk = MemoryChunk(
                id="circular-test",
                workspace_id="test",
                content="test",
                memory_type=MemoryType.FOUNDATION,
                metadata=data,
            )

            # Try to serialize
            chunk_dict = chunk.to_dict()
            chunk_json = json.dumps(chunk_dict)

            # If we get here, circular reference was handled
            return True
        except Exception as e:
            if "circular" in str(e).lower():
                raise e  # Circular reference not handled
            return True  # Other exception is fine

    def test_deep_nesting(self):
        """Test deep nesting handling."""

        # Create deeply nested structure
        def create_deep_nesting(depth):
            if depth <= 0:
                return "leaf"
            return {"level": depth, "nested": create_deep_nesting(depth - 1)}

        deep_structure = create_deep_nesting(1000)

        try:
            chunk = MemoryChunk(
                id="deep-nesting-test",
                workspace_id="test",
                content="test",
                memory_type=MemoryType.FOUNDATION,
                metadata=deep_structure,
            )

            # Try to serialize
            chunk_dict = chunk.to_dict()
            chunk_json = json.dumps(chunk_dict)

            return True
        except Exception as e:
            if "maximum recursion depth" in str(e).lower():
                raise e  # Deep nesting not handled
            return True  # Other exception is fine

    def test_malicious_json(self):
        """Test malicious JSON handling."""
        malicious_jsons = [
            '{"__class__": "os.system", "__module__": "os", "__args__": ["echo pwned"]}',
            '{"__reduce__": ["eval", ["__import__("os").system("echo pwned")"]]}',
            '{"__import__": "subprocess", "__call__": ["Popen", ["echo pwned"]]}',
        ]

        for malicious_json in malicious_jsons:
            try:
                data = json.loads(malicious_json)

                chunk = MemoryChunk(
                    id="malicious-json-test",
                    workspace_id="test",
                    content="test",
                    memory_type=MemoryType.FOUNDATION,
                    metadata=data,
                )

                # Try to serialize back
                chunk_dict = chunk.to_dict()
                chunk_json = json.dumps(chunk_dict)

                # Check if dangerous attributes are still present
                if "__class__" in chunk_json or "__reduce__" in chunk_json:
                    self.log_vulnerability(
                        "MALICIOUS_JSON",
                        f"Malicious JSON not sanitized: {malicious_json}",
                    )

            except Exception as e:
                # Exception is fine - malicious JSON rejected
                pass

    def test_5_critical_business_logic(self):
        """Test critical business logic vulnerabilities."""
        print("\nüîç Test 5: Critical Business Logic")

        try:
            # Test business logic violations
            business_logic_tests = [
                # Self-referencing relationships
                lambda: self.test_self_referencing(),
                # Workspace boundary violations
                lambda: self.test_workspace_boundaries(),
                # Invalid enum values
                lambda: self.test_invalid_enums(),
            ]

            for i, test_func in enumerate(business_logic_tests):
                try:
                    test_func()
                    self.log_pass(
                        "BUSINESS_LOGIC",
                        f"Test {i+1}: Business logic handled correctly",
                    )
                except Exception as e:
                    self.log_vulnerability(
                        "BUSINESS_LOGIC",
                        f"Test {i+1}: Business logic vulnerability: {e}",
                    )

        except Exception as e:
            self.log_vulnerability("BUSINESS_LOGIC", f"Test failed: {e}")

    def test_self_referencing(self):
        """Test self-referencing relationships."""
        rel = GraphRelationship(
            id="self-ref-test",
            workspace_id="test",
            source_id="entity1",
            target_id="entity1",  # Same source and target
            relation_type=RelationType.RELATED_TO,
        )

        if rel.is_valid():
            self.log_vulnerability(
                "SELF_REFERENCING", "Self-referencing relationship allowed"
            )
        else:
            self.log_pass("SELF_REFERENCING", "Self-referencing relationship blocked")

    def test_workspace_boundaries(self):
        """Test workspace boundary violations."""
        entity1 = GraphEntity(
            id="entity1",
            workspace_id="ws1",
            entity_type=EntityType.COMPANY,
            name="Entity 1",
        )

        entity2 = GraphEntity(
            id="entity2",
            workspace_id="ws2",
            entity_type=EntityType.COMPANY,
            name="Entity 2",
        )

        # Create cross-workspace relationship
        cross_ws_rel = GraphRelationship(
            id="cross-ws-test",
            workspace_id="ws1",
            source_id="entity1",
            target_id="entity2",  # Different workspace
            relation_type=RelationType.RELATED_TO,
        )

        if cross_ws_rel.is_valid(entity1, entity2):
            self.log_vulnerability(
                "WORKSPACE_BOUNDARY", "Cross-workspace relationship allowed"
            )
        else:
            self.log_pass("WORKSPACE_BOUNDARY", "Cross-workspace relationship blocked")

    def test_invalid_enums(self):
        """Test invalid enum values."""
        try:
            # Try to create with invalid enum
            chunk = MemoryChunk(
                id="invalid-enum-test",
                workspace_id="test",
                content="test",
                memory_type="INVALID_TYPE",  # Invalid enum
            )

            self.log_warning("INVALID_ENUM", "Invalid enum type accepted")
        except Exception as e:
            self.log_pass(
                "INVALID_ENUM", f"Invalid enum type rejected: {type(e).__name__}"
            )

    def run_all_tests(self):
        """Run all critical vulnerability tests."""
        print("=" * 80)
        print("üî• CRITICAL VULNERABILITY SCANNER üî•")
        print("Finding the most critical vulnerabilities that could break the system")
        print("=" * 80)

        # Run all tests
        self.test_1_critical_input_validation()
        self.test_2_critical_type_safety()
        self.test_3_critical_boundary_conditions()
        self.test_4_critical_serialization_attacks()
        self.test_5_critical_business_logic()

        # Print summary
        self.print_summary()

    def print_summary(self):
        """Print test summary."""
        print("\n" + "=" * 80)
        print("üìä CRITICAL VULNERABILITY SCAN SUMMARY")
        print("=" * 80)

        print(f"üö® Critical Vulnerabilities: {len(self.vulnerabilities)}")
        print(f"‚ö†Ô∏è Warnings: {len(self.warnings)}")
        print(f"‚úÖ Passed: {len(self.passed)}")

        if self.vulnerabilities:
            print("\nüö® CRITICAL VULNERABILITIES FOUND:")
            for vuln in self.vulnerabilities:
                print(f"  üí• {vuln['test']}: {vuln['description']}")

        if self.warnings:
            print("\n‚ö†Ô∏è WARNINGS:")
            for warning in self.warnings:
                print(f"  ‚ö†Ô∏è {warning['test']}: {warning['description']}")

        if not self.vulnerabilities:
            print("\nüéâ NO CRITICAL VULNERABILITIES FOUND!")
            print("üõ°Ô∏è System appears to be secure against critical attacks")
        else:
            print(
                f"\nüö® {len(self.vulnerabilities)} CRITICAL VULNERABILITIES REQUIRE IMMEDIATE ATTENTION!"
            )

        print("=" * 80)

        # Return status
        return len(self.vulnerabilities) == 0


if __name__ == "__main__":
    scanner = CriticalVulnerabilityScanner()
    success = scanner.run_all_tests()
    sys.exit(0 if success else 1)
